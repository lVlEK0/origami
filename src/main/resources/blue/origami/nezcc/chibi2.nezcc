# konoha5.nezcc

extension          = chibi

# type

Bool               = Bool
Byte               = Char
Byte[]             = Char[]
Int                = Int
Int64              = Int
Array              = %s[]
Symbol             = String
Tree               = Option[{tkey,subtrees,tvalue}]
String             = String
Int32              = Int

TtreeLog           = Option[{lop,lpos,tree,treeLog}]
Tstate             = Option[{ntag,cnt,value,state}]
Tm                 = {key,result,mpos,tree,state}
Tmemos             = $|Tm|[]
Tpx                = {inputs,length,pos,headpos,tree,treeLog,state,memos}
# Tpx                = {inputs,length,pos,headpos,tree,treeLog,newFunc,setFunc,state,memos}
Tsubtrees          = Option[{subtlabel,subtrees,tree}]
TnewFunc           = ($|Symbol|,$|Byte[]|,$|Int|,$|Int|,$|Tsubtrees|) -> $|Tree|
TsetFunc           = ($|Tree|,$|Int|,$|Symbol|,$|Tree|) -> $|Tree|
Tf                 = ($|Tpx|) -> $|Bool|

Option            = Option[%s]
Some              = Some(%s)
None              = None
Option.get        = ({lop,lpos,tree,treeLog}) %s
Option.isNone     = !(Some?(%s))

TreeList.empty     = None
TreeList.cons      = Some({subtlabel: %1$s, subtrees: %3$s, tree: %2$s})

px.newFunc         = newAST

String->Byte[]     = ($|Byte[]|) (%s)

array              = [
arrays             = ,
end array          = ]
struct             =
end struct         =

mtree              = tree
ltree              = tree
lprev              = treeLog
mstate             = state
sprev              = state

Array.size         = |%s|
Array.get          = %s[%s]
Array.new          = []

# syntax

comment            = // %s
begin              = {
end                = }
delim              = ,

const            = %2$s = %3$s
val              = $|const|
var              = $|const|
assign           = %s = %s

function         = %1$s %2$s(%3$s) =
end function     =
param            = %2$s
params           = ,
return           = %s

object           = {%2$s}
objectparam      = %1$s: %2$s
objectparams     = ,

cast             = (%s) %s

if               = if %s {
else if          = else if %s {
switch           = match %s
end switch       =
case             = case %s => %s
default          = case _ => %s
ifexpr           = if %1$s then %2$s else %3$s

null             = None
lambda           = \%s -> %s
;                =

imports = '''
assume tkey, subtlabel, text, tag: $|Symbol|
assume tvalue, value, inputs, bits: $|Byte[]|
assume lop, lpos, ntag, cnt, key, result, mpos, length, pos, epos, headpos, shift, mpoint, nlabel, nvalue: $|Int|
assume matched: $|Bool|
t = {tree: Some({tkey: "", subtrees: Some({subtlabel: "", subtrees: Some({subtlabel: "", subtrees: None, tvalue: ['a']}), tree: None}), tvalue: ['a']})}
tl = {treeLog: Some({lop: 0, lpos: 1, tree: None, treeLog: None})}
tc = {tcur: {lop: 0, lpos: 1, tree: None, treeLog: None}}
s = {state: Some({ntag: 0, cnt: 0, value: ['a'], state: None})}
// assume newFunc: $|TnewFunc|
// assume setFunc: $|TsetFunc|
assume m: $|Tm|, memos: $|Tmemos|
assume px: $|Tpx|, f: $|Tf|
'''

def backpos = '''
$|Int| backpos2(px, pos) =
  px.headpos = pos
  pos

$|Int| backpos(px, pos) =
  if px.headpos < pos then backpos2(px, pos) else pos

'''

def logT = '''
Bool logT(px,lop,lpos,tree) =
  treeLog = Some({lop: lop,lpos: lpos,tree: tree,treeLog: px.treeLog})
  px.treeLog = treeLog
  true

'''

def parse = '''
$|Tmemos| rMemo(memos, tree, cnt, length) =
  if (cnt < length) then rMemo({key: -1, result: 0, mpos: 0, tree: tree, state: $|null|}::memos, tree, cnt+1, length) else memos

$|Tmemos| newMemos(tree, length) =
  rMemo([],tree,0,length)

$|Tree| parse(inputs, length) =
  tree = newAST(gettag(0),inputs,0,length,$|null|)
  px = {inputs: inputs,length: length,pos: 0,headpos: 0,tree: tree,treeLog: Some({lop: 0,lpos: 0,tree: tree,treeLog: $|null|}),state: $|null|,memos: newMemos(tree,257)}
  tree = if e0(px) then px.tree else newAST(gettag(nezerror),inputs,px.headpos,length,$|null|)
  tree

$|Tree| parseText(text) =
  inputs = ($|Byte[]|) text
  parse(inputs,|inputs|)

'''

def AST = '''
$|Symbol| Subtlabel_dump(subtlabel) =
  if subtlabel == "" then "" else "$" ++ subtlabel ++ "="

$|Symbol| Subttree_dump(tree) =
  if Some?(tree) then Tree_dump(({tkey,subtrees,tvalue}) tree) else ""

$|Symbol| Subtnext_dump(subtrees) =
  if Some?(subtrees) then Subtree_dump(({subtlabel,subtrees,tree}) subtrees) else ""

$|Symbol| Subtree_dump(subtree: {subtlabel,subtrees,tree}) =
  Subtlabel_dump(subtree.subtlabel) ++ Subttree_dump(subtree.tree) ++ Subtnext_dump(subtree.subtrees)

$|Symbol| Tree_dump(tr: {tkey,subtrees,tvalue}) =
  value = tr.tvalue
  "[#" ++ tr.tkey ++ " " ++ (if |value| != 0 then ("'" ++ (String) tr.tvalue ++ "'") else (Subtree_dump(({subtlabel,subtrees,tree}) tr.subtrees))) ++ "]"

'''

def newAST = '''
$|Tree| newAST(tag, inputs, pos, epos, subtrees) =
  Some({tkey: tag, subtrees: subtrees, tvalue: if Some?(subtrees) then [] else inputs[pos.. epos]})

'''

def subAST = '''

'''

# def subAST = '''
$|Tree| subAST(tree, n, tag, tr: Option[{tkey,subtrees,tvalue}]) = tree

'''

main = '''
$|Symbol| readInputs(path: String) =
  file = loadFile(path)
  if file == "" then path else file

sub(input: String) =
  file = readInputs(input)
  start = time(0.0)
  data = parseText(file)
  time = difTime(start)
  println(input ++ " " ++ (String)(time) ++ "[ms]:\n" ++ input ++ ": ")
  println(Tree_dump(({tkey,subtrees,tvalue}) data))
  println("")

main(av: String[]) =
  if |av| == 1 then println("Usage: " ++ av[0] ++ "file [or 'input-text']\n") else av[1.. |av|].map(\a -> main2(a))
'''

man = '''
=============
 INTEGRATION
=============

Just call the following function to parse a tree.

Tree *Nez_parseTree(const char *inputs);

Example (in $|base|.c)

   Tree *t = Nez_parseTree("sometext");
   if(t != NULL) {
      Tree_dump(t);
   }

NOTE: This parser has no GC support for trees.
Add some reference counting for trees.

=============
 QUICK START
=============

 make $|base| CFLAGS='-g -O3'
 ./$|base| <file> or <input-text>

Read the main function. You will know how to
integrate the parser into your programs.
'''
