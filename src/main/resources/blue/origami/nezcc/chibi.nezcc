# chibi.nezcc

extension          = chibi

# type

Bool               = Bool
Byte               = Char
Byte[]             = Char[]
Int                = Int
Int64              = Int
Array              = %s[]
Symbol             = String
# Tree               = Option[{tkey,subtrees,tvalue}]
Tree               = Option[Any]
String             = String
Int32              = Int

mtree              = tree
ltree              = tree
lprev              = treeLog
mstate             = state
sprev              = state
m                  = memo$
px                 = px$

Ttcur              = {lop,lpos,$|ltree|,$|lprev|}
TtreeLog           = Option[Any]
# Tstate             = Option[{ntag,cnt,value,$|sprev|}]
Tstate             = Option[Any]
Tm                 = {key,result,mpos,$|mtree|,$|mstate|}$
Tmemos             = $|Tm|[]
Tpx                = {inputs,length,pos,headpos,tree,treeLog,state,memos}
# Tsubtrees          = Option[{subtlabel,subtrees,tree}]
Tsubtrees          = Option[Any]
TnewFunc           = ($|Symbol|,$|Byte[]|,$|Int|,$|Int|,$|Tsubtrees|) -> $|Tree|
TsetFunc           = ($|Tree|,$|Int|,$|Symbol|,$|Tree|) -> $|Tree|
Tf                 = ($|Tpx|$) -> $|Bool|

Option            = Option[%s]
Some              = Some(%s)
None              = None
Option.get        = ({lop,lpos,tree,treeLog})(Any) %s
Option.isNone     = !(Some?(%s))

TreeList.empty     = None
TreeList.cons      = Some((Any){subtlabel: %1$s, subtrees: %3$s, tree: %2$s})

px$.newFunc         = newAST

String->Byte[]     = ($|Byte[]|) (%s)

array              = [
arrays             = ,
end array          = ]
struct             =
end struct         =

Array.size         = |%s|
Array.get          = %s[%s]
Array.new          = []

# syntax

comment            = // %s
begin              = {
end                = }
delim              = ,

const            = %2$s = %3$s
val              = $|const|
var              = $|const|
assign           = %s = %s

function         = %1$s %2$s(%3$s) =
end function     =
param            = %2$s
params           = ,
return           = %s

object           = {%2$s}
objectparam      = %1$s: %2$s
objectparams     = ,

cast             = (%s) %s

if               = if %s {
else if          = else if %s {
switch           = match %s
end switch       =
case             = case %s => %s
default          = case _ => %s
ifexpr           = if %1$s then %2$s else %3$s

null             = None
lambda           = \%s -> %s
;                =

imports = '''
assume tkey, subtlabel, text, tag: $|Symbol|
assume tvalue, value, inputs: $|Byte[]|
assume bits: Int[]
assume lop, lpos, ntag, cnt, key, result, mpos, length, pos, epos, headpos, shift, mpoint, nlabel, nvalue: $|Int|
assume matched: $|Bool|
assume tree, subtrees, treeLog, state: Option[Any]
assume tcur: $|Ttcur|
assume memo: {key,result,mpos,tree,state}, memos: $|Tmemos|
assume px, p: $|Tpx|, f: $|Tf|
'''
# t = {tree: Some({tkey: "", subtrees: Some({subtlabel: "", subtrees: Some({subtlabel: "", subtrees: None, tree: None}), tree: None}), tvalue: ['a']})}
# assume tree, mtree, ltree: $|Tree|, subtrees: $|Tsubtrees|
# tl = {treeLog: Some({lop: 0, lpos: 1, tree: None, treeLog: None})}
# assume treeLog, lprev: $|TtreeLog|
# tc = {tcur: {lop: 0, lpos: 1, tree: None, treeLog: None}}
# s = {state: Some({ntag: 0, cnt: 0, value: ['a'], state: None})}
# assume state, mstate, sprev: $|Tstate|

def backpos = '''
$|Int| backpos2($|px|, pos) =
  $|px|.headpos = pos
  pos

$|Int| backpos($|px|, pos) =
  if $|px|.headpos < pos then backpos2($|px|, pos) else pos

'''

def logT = '''
Bool logT($|px|,lop,lpos,tree) =
  treeLog = Some({lop: lop, lpos: lpos, tree: tree, $|lprev|: $|px|.treeLog})
  $|px|.treeLog = treeLog
  true

'''

def parse = '''
$|Tmemos| rMemo($|memos|, tree, cnt, length) =
  if (cnt < length) then rMemo({key: -1, result: 0, mpos: 0, $|mtree|: tree, $|mstate|: $|null|}::$|memos|, tree, cnt+1, length) else $|memos|

$|Tmemos| newMemos(tree, length) =
  rMemo([{key: -1, result: 0, mpos: 0, $|mtree|: tree, $|mstate|: $|null|}],tree,1,length)

$|Tree| parse(inputs, length) =
  tree = newAST(gettag(0),inputs,0,length,$|null|)
  $|px| = {inputs: inputs,length: length,pos: 0,headpos: 0,tree: tree,treeLog: Some({lop: 0,lpos: 0,tree: tree,treeLog: $|null|}),state: $|null|,$|memos|: newMemos(tree,257)}
  tree = if e0($|px|) then $|px|.tree else newAST(gettag(nezerror),inputs,$|px|.headpos,length,$|null|)
  tree

$|Tree| parseText(text) =
  inputs = ($|Byte[]|) text ++ ['\0']
  parse(inputs,|inputs|)

'''

def AST = '''
$|Symbol| Subtlabel_dump(subtlabel) =
  if subtlabel == "" then "" else "$" ++ subtlabel ++ "="

$|Symbol| Subttree_dump(tree) =
  if Some?(tree) then Tree_dump(({tkey,subtrees,tvalue})(Any) tree) else ""

$|Symbol| Subtnext_dump(subtrees) =
  if Some?(subtrees) then Subtree_dump(({subtlabel,subtrees,tree})(Any) subtrees) else ""

$|Symbol| Subtree_dump(subtree: {subtlabel,subtrees,tree}) =
  Subtlabel_dump(subtree.subtlabel) ++ Subttree_dump(subtree.tree) ++ Subtnext_dump(subtree.subtrees)

$|Symbol| Tree_dump(tr: {tkey,subtrees,tvalue}) =
  value = tr.tvalue
  "[#" ++ tr.tkey ++ " " ++ (if |value| != 0 then ("'" ++ (String) tr.tvalue ++ "'") else (Subtree_dump(({subtlabel,subtrees,tree})(Any) tr.subtrees))) ++ "]"

'''

def newAST = '''
$|Tree| newAST(tag, inputs, pos, epos, subtrees) =
  Some((Any){tkey: tag, subtrees: subtrees, tvalue: if Some?(subtrees) then [] else inputs[pos.. epos]})

'''

def subAST = '''

'''

# def subAST = '''
$|Tree| subAST(tree, n, tag, tr: Option[Any]) = tree

'''

main = '''
String readInputs(path: String) =
  file = loadFile(path)
  if file == "" then path else file

String sub(input: String) =
  file = readInputs(input)
  start = time(0.0)
  data = parseText(file)
  time = difTime(start)
  input ++ " " ++ (String)(time) ++ "[ms]:" ++ "\n" ++ Tree_dump(({tkey,subtrees,tvalue})(Any) data)

main3(argv: String[], index: Int) =
  println(sub(argv[index]))
  main2(argv, index + 1)

main2(argv: String[], index: Int) =
  if (index + 1 < |argv|) then main3(argv, index) else println(sub(argv[index]))

main(argv: String[]) =
  if |argv| == 1 then println("Usage: " ++ argv[0] ++ "file [or 'input-text']\n") else main2(argv, 1)

sub("xmark10.xml")
'''

man = '''
=============
 INTEGRATION
=============

Just call the following function to parse a tree.

Tree *Nez_parseTree(const char *inputs);

Example (in $|base|.c)

   Tree *t = Nez_parseTree("sometext");
   if(t != NULL) {
      Tree_dump(t);
   }

NOTE: This parser has no GC support for trees.
Add some reference counting for trees.

=============
 QUICK START
=============

 make $|base| CFLAGS='-g -O3'
 ./$|base| <file> or <input-text>

Read the main function. You will know how to
integrate the parser into your programs.
'''
